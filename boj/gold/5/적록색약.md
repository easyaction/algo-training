[link](https://www.acmicpc.net/problem/10026)
### 문제 이해
NxN 배열 값 - R,G,B 중 하나
같은 색으로 이뤄진 여러개의 구역으로 이뤄짐
적록색약은 빨강과 녹색을 구분하지 못하므로, 같은 구역으로 처리
그림이 주어졌을때 적록색약인 사람과 아닌사람이 봤을때 구역의 수 구하기
N<=100
### 추상화
배열을 bfs로 탐색
한번은 R과 G를 구분하고, 한번은 R과 G를 동일 색상으로 취급
	아예 배열을 동일 색상으로 초기화하고 배열 두개를 각각 구하자.
배열을 순회하면서 인접한 동일 색상의 배열을 방문처리. 
	방문한 적이 없으면 해당 색상 카운터를 증가

### 계획
배열 초기화
방문 여부 배열 초기화(NxN)
R,G,B 카운터 초기화
배열을 순회하며 bfs로 탐색
	방문한 적이 없으면 counter 증가하고, 주변 탐색
		인접 배열을 보고 동일 색상이면 방문처리 및 큐에 인입
	방문하였으면 스킵

### 코드
```python
import sys

input = sys.stdin.readline
from collections import deque


def solve(arr: list[list[str]]) -> int:
    cnt = 0
    N = len(arr)
    visited = [[False] * len(arr) for _ in range(N)]
    dirs = [(1, 0), (-1, 0), (0, 1), (0, -1)]
    for i in range(N):
        for j in range(N):
            if visited[i][j]:
                continue
            cnt += 1
            visited[i][j] = True
            q = deque([(i, j)])
            while q:
                x, y = q.popleft()
                for dx, dy in dirs:
                    nxt_x, nxt_y = x + dx, y + dy
                    if (
                        0 <= nxt_x < N
                        and 0 <= nxt_y < N
                        and not visited[nxt_x][nxt_y]
                        and arr[x][y] == arr[nxt_x][nxt_y]
                    ):
                        visited[nxt_x][nxt_y] = True
                        q.append((nxt_x, nxt_y))
    return cnt


if __name__ == "__main__":
    N = int(input())
    arr_1 = []
    arr_2 = []
    for _ in range(N):
        row = list(input().rstrip())
        arr_1.append(row)
        arr_2.append(["R" if val == "G" else val for val in row])
    print(solve(arr_1), solve(arr_2))

```
개선
```python
import sys

input = sys.stdin.readline
from collections import deque


def is_same_color(c1: str, c2: str, is_blind: bool) -> bool:
    if is_blind:
        return c1 == c2 or c1 in "RG" and c2 in "RG"
    return c1 == c2


def solve(arr: list[list[str]], is_blind: bool) -> int:
    cnt = 0
    N = len(arr)
    visited = [[False] * N for _ in range(N)]
    dirs = [(1, 0), (-1, 0), (0, 1), (0, -1)]
    for i in range(N):
        for j in range(N):
            if visited[i][j]:
                continue
            cnt += 1
            visited[i][j] = True
            q = deque([(i, j)])
            while q:
                x, y = q.popleft()
                for dx, dy in dirs:
                    nx, ny = x + dx, y + dy
                    if (
                        0 <= nx < N
                        and 0 <= ny < N
                        and not visited[nx][ny]
                        and is_same_color(arr[x][y], arr[nx][ny], is_blind)
                    ):
                        visited[nx][ny] = True
                        q.append((nx, ny))
    return cnt


if __name__ == "__main__":
    N = int(input())
    arr = [list(input().rstrip()) for _ in range(N)]
    print(solve(arr, False), solve(arr, True))

```
### 회고
N이 크지않아 그냥 배열 두개를 선언해서 처리했는데, 동일 색상 판단 여부를 함수로 추출하면 간단하게 해결 가능