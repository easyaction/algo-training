[link](https://www.acmicpc.net/problem/1931)
### 문제 이해
한개의 회의실 N개의 회의
사용표를 만들자.
회의 I에 대해 시작시간, 끝나는시간
각 회의가 겹치지 않게 회의실을 사용할수 있는 회의의 최대 갯수
입력
회의의 수 1<= N <= 100,000
n개 줄의 회의 정보 시작시간 끝나는 시간
 
### 추상화
회의 시작시간, 끝나는 시간 기준으로 정렬한 뒤, 최적의 시간대를 고르기?
	회의시간이 짧은 시간을 여러개 고르는게 더 최적일 것 같은데...
0 6 - 6시간
1 4 - 3시간
2 13 - 11시간
3 5 - 2시간
3 8 - 5시간
5 7 - 2시간
5 9 - 4시간
6 10 - 4시간
8 11 - 3시간 
8 12 - 4시간
12 14 - 2시간
가장 많은 회의를 수행하기 위해서는 특정 시각 기준으로 회의가 최대한 많이 종료되어있어야함 그래야 미래의 회의를 수행할 수 있기 때문
따라서 종료 시간을 기준으로 정렬하고, 회의를 하나씩 추가하되 오버랩이 발생하면 종료 시각이 빠른 회의를 선택
### 계획
회의들을 정렬
정렬된 회의를 순회하며 오버랩 여부를 확인, 발생하지 않으면 배열에 추가
	오버랩이 발생하지 않는 경우에만 cnt 증가
### 코드
```python
import sys

input = sys.stdin.readline


def solve(N: int, meetings: list[tuple]) -> int:
    meetings.sort(key=lambda x: (x[1], x[0]))
    last = meetings[0]
    cnt = 1
    for i in range(1, N):
        cur = meetings[i]
        start, _ = cur
        _, last_end = last
        if last_end <= start:
            cnt += 1
            last = cur
    return cnt


if __name__ == "__main__":
    [N] = map(int, input().split())
    meetings = []
    for _ in range(N):
        (start, end) = map(int, input().split())
        meetings.append((start, end))
    print(solve(N, meetings))

```
개선
```python
import sys

input = sys.stdin.readline


def solve(N: int, meetings: list[tuple]) -> int:
    meetings.sort(key=lambda x: (x[1], x[0]))
    last_end = -int(1e9)
    cnt = 0
    for start, end in meetings:
        if last_end <= start:
            cnt += 1
            last_end = end
    return cnt


if __name__ == "__main__":
    [N] = map(int, input().split())
    meetings = []
    for _ in range(N):
        (start, end) = map(int, input().split())
        meetings.append((start, end))
    print(solve(N, meetings))

```
### 회고
방향성 못잡아서 분류, 질문 게시판 확인하고 힌트도 추가로 받음
	종료 시간 기준으로 최적의 회의를 선택하도록..
불필요한 정보 저장
	last의 start는 필요하지 않음
N == 0일때의 처리 없음
	조건에서 N >= 1이라 직접 값을 설정하고 배열을 그 다음 인덱스부터 순회했는데, 좋지 못한 습관
추가로 비슷한 문제 풀어보아야함.
