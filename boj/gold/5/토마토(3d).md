[link](https://www.acmicpc.net/problem/7569)
### 문제 이해
토마토를 격자모양 상자에 보관. MxNxH
안익은 토마토와 익은 토마토가 있는데, 익은 토마토에 인접하면 하루 뒤 익음
인접한 방향은 위아래왼오른쪽 앞뒤 총 여섯방향
토마토가 안들어있는 경우도 있다.
입력
M, N, H <= 100
MxN이 H만큼 반복 
익은 토마토 1, 익지않은 토마토 0, 토마토 없음 -1
토마토가 모두 익을때까지 최소 며칠 걸리는지?
처음부터 다익으면 0
모두 익지 못하면 -1
### 추상화
3차원 배열에서의 bfs 탐색 문제
	익은 토마토의 좌표를 저장해뒀다가 탐색을 전부 하면서 익은 토마토의 갯수를 세서 이게 모든 토마토 수와 일치하는지 확인
	탐색시마다 익은 토마토의 갯수와 모든 토마토의 갯수가 일치하는지 확인하여 같으면 종료
	
### 계획
3차원 배열 초기화
	익은 토마토의 위치를 저장
익은 토마토와 배열을 전달받아 bfs하는 함수 호출
	상하좌우앞뒤를 탐색
		탐색전 익은 토마토 갯수와 전체 토마토 갯수 체크
		step = day
전체가 다 익지 못하고 큐가 비워지면, -1 (다 익지 못함)

### 코드
```python
import sys

input = sys.stdin.readline
from collections import deque


def solve(
    boxes: list[list[list[int]]],
    start_xyz: list[tuple],
    total_cnt: int,
    M: int,
    N: int,
    H: int,
) -> int:
    ripe_cnt = len(start_xyz)
    if total_cnt == ripe_cnt:
        return 0
    dirs = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]
    max_days = 0
    q = deque(start_xyz)
    while q:
        i, j, k = q.popleft()
        for dx, dy, dz in dirs:
            nxt_i, nxt_j, nxt_k = i + dx, j + dy, k + dz
            if 0 <= nxt_i < M and 0 <= nxt_j < N and 0 <= nxt_k < H:
                if boxes[nxt_k][nxt_j][nxt_i] == 0:
                    boxes[nxt_k][nxt_j][nxt_i] = boxes[k][j][i] + 1
                    ripe_cnt += 1
                    max_days = max(max_days, boxes[k][j][i] + 1)
                    q.append((nxt_i, nxt_j, nxt_k))
    return -1 if total_cnt != ripe_cnt else max_days - 1


if __name__ == "__main__":
    [M, N, H] = map(int, input().split())
    boxes = []
    start_xyz = []
    empty = 0
    for k in range(H):
        MN = []
        for j in range(N):
            row = list(map(int, input().split()))
            for i in range(M):
                if row[i] == 1:
                    start_xyz.append((i, j, k))
                elif row[i] == -1:
                    empty += 1
            MN.append(row)
        boxes.append(MN)
    total_tomatoes = M * N * H - empty
    print(solve(boxes, start_xyz, total_tomatoes, M, N, H))

```
개선
```python
import sys
from collections import deque

input = sys.stdin.readline

DIRECTIONS_3D = [(1,0,0), (-1,0,0), (0,1,0), (0,-1,0), (0,0,1), (0,0,-1)]

def solve(
    boxes: list[list[list[int]]],
    start_pos: list[tuple[int, int, int]],
    total_cnt: int,
    M: int, N: int, H: int
) -> int:
    ripe_cnt = len(start_pos)
    
    if total_cnt == ripe_cnt:
        return 0
    
    last_day = 0
    q = deque(start_pos)
    
    while q:
        x, y, z = q.popleft()
        current_day = boxes[z][y][x]
        
        for dx, dy, dz in DIRECTIONS_3D:
            nx, ny, nz = x + dx, y + dy, z + dz
            
            if 0 <= nx < M and 0 <= ny < N and 0 <= nz < H:
                if boxes[nz][ny][nx] == 0:
                    boxes[nz][ny][nx] = current_day + 1
                    last_day = current_day + 1
                    ripe_cnt += 1
                    q.append((nx, ny, nz))
    
    return -1 if total_cnt != ripe_cnt else last_day - 1


if __name__ == "__main__":
    M, N, H = map(int, input().split())
    
    boxes = []
    start_pos = []
    empty = 0
    
    for z in range(H):
        layer = []
        for y in range(N):
            row = list(map(int, input().split()))
            for x in range(M):
                if row[x] == 1:
                    start_pos.append((x, y, z))
                elif row[x] == -1:
                    empty += 1
            layer.append(row)
        boxes.append(layer)
    
    total_cnt = M * N * H - empty
    print(solve(boxes, start_pos, total_cnt, M, N, H))

```
### 회고
가독성을 위한 개선
	i, j, k 대신 x,y,z로 통일
탐색하며 탐색 길이를 저장하기 때문에 별도로 max를 매번 할 필요가 없음
	마지막 길이에서 -1 해주면 됨