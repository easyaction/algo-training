[link](https://www.acmicpc.net/problem/11403)
### 문제 이해
방향 그래프 G에서 모든 정점 i,j에 대해서 i -> j로 가는 길이가 양수인 경로기 있는지 없는지 구하라 
입력
정점 갯수 N ( <= 100)
인접 행렬 NxN
출력
i -> j 양수 경로 있으면 1, 아니면 0
### 추상화
그래프 탐색? bfs?
	브루트 포스로 dfs/bfs로 정점 1->N 까지 매번 새롭게 방문하면?
		정답은 각 노드에서의 visited 결과
	O(N^3)?

### 계획
그래프 초기화
정점 1부터 N까지 순회하며
	bfs로 간선 탐색
	visited를 만들어 결과 배열에 append
### 코드
bfs
```python
import sys

input = sys.stdin.readline
from collections import deque


def solve(arr: list[list[int]], N: int) -> list[list[int]]:
    results = []
    for start in range(N):
        visited = [0] * N
        q = deque([start])
        while q:
            i = q.popleft()
            for j in range(N):
                nxt = arr[i][j]
                if nxt == 0 or visited[j]:
                    continue
                visited[j] = 1
                q.append(j)
        results.append(visited)
    return results


if __name__ == "__main__":
    [N] = map(int, input().split())
    arr = []
    for _ in range(N):
        arr.append(list(map(int, input().split())))
    results = solve(arr, N)
    for r in results:
        print(" ".join(map(str, r)))
```
플로이드워셜
```python
import sys

input = sys.stdin.readline


def solve(arr: list[list[int]], N: int) -> list[list[int]]:
    for k in range(N):
        for i in range(N):
            if arr[i][k] == 1:
                for j in range(N):
                    if arr[k][j] == 1:
                        arr[i][j] = 1
    return arr


if __name__ == "__main__":
    [N] = map(int, input().split())
    arr = []
    for _ in range(N):
        arr.append(list(map(int, input().split())))
    results = solve(arr, N)
    for r in results:
        print(" ".join(map(str, r)))

```
### 회고
플로이드 워셜로 모든 정점 대상으로 최단 경로 구하는 것도 가능
	i,k가 가능하고 k,j가 가능하면 i,j도 가능
		boolean 플로이드 워셜