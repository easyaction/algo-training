[link](https://www.acmicpc.net/problem/2178)
### 문제 이해
NxM 미로. 1x1에서 출발하여 NxM의 위치로 이동할때 지나야하는 최소 칸수 구하기
첫째줄 두 정수 2<= n, m <= 100
N개의 줄에 m개의 정수. 각 수는 붙어서 입력으로 받음
1은 이동 가능 0은 이동 불가능
### 추상화
BFS를 이용한 탐색
이동 가능한 경로에 대해서만 q에 넣고 n x m에 도달하는 최소 스텝을 구하기
방문여부 별도 배열로 저장하지 않고 방문시에 1->0으로 변환
### 계획
배열 초기화
	input().rstrip()으로 문자열을 배열로 파싱
bfs with deque
	x,y 좌표와 step을 함께 넣어 조건 만족시 q에 넣기 
### 코드
```python
import sys
input = sys.stdin.readline
from collections import deque

def solve(maze:list[list[int]], N:int, M:int)-> int:
    q = deque([(0, 0, 1)]) # (x, y, step)
    maze[0][0] = 0
    dirs = [(1,0), (0, 1), (-1, 0), (0,-1)]
    while q:
        x, y, step = q.popleft()
        if x == N-1 and y == M-1:
            return step
        for dx, dy in dirs:
            nxt_x, nxt_y = x + dx, y + dy
            if  0<=nxt_x<N and 0<=nxt_y<M and maze[nxt_x][nxt_y] == 1:
                maze[nxt_x][nxt_y] = 0
                q.append((nxt_x, nxt_y, step+1))
    return -1


if __name__ == "__main__":
    N, M = map(int, input().split())
    maze = []
    for _ in range(N):
        maze.append(list(map(int, input().rstrip())))
    print(solve(maze, N, M))
```
개선
```python
import sys
input = sys.stdin.readline
from collections import deque

def solve(maze:list[list[int]], N:int, M:int)-> int:
    q = deque([(0, 0)]) # (x, y)
    dirs = [(1,0), (0, 1), (-1, 0), (0,-1)]
    while q:
        x, y = q.popleft()
        if x == N-1 and y == M-1:
            return maze[x][y]
        for dx, dy in dirs:
            nxt_x, nxt_y = x + dx, y + dy
            if  0<=nxt_x<N and 0<=nxt_y<M and maze[nxt_x][nxt_y] == 1:
                maze[nxt_x][nxt_y] = maze[x][y] + 1
                q.append((nxt_x, nxt_y))
    return -1


if __name__ == "__main__":
    N, M = map(int, input().split())
    maze = []
    for _ in range(N):
        maze.append(list(map(int, input().rstrip())))
    print(solve(maze, N, M))

```
### 회고
step을 큐에 같이 넣었는데, 거리를 저장하는 것이 더 효율적
	굳이 1->0으로 변환하지 않고, 기존 배열을 활용