[link](https://www.acmicpc.net/problem/30804)
### 문제 이해
막대에 N개의 과일
과일 1~9 9가지 종류
과일을 두종류 이하 사용해야함
앞에서 a개 뒤에서 b개 빼서 두종류만 만들기
이렇게 두종류만 사용한 탕후루 중 가장 과일 갯수가 많은 N - (a+b) 의 최대값을 구하라
입력 N <= 2 * 10 ^ 5
과일 N개 공백구분 입력

### 추상화
브루트포스로 하면 queue에 숫자를 조건에 따라 넣고 빼면서 숫자 종류별 갯수를 계산
투포인터..?
counter로 숫자 갯수 검사하고, deque로 조건에 따라 앞숫자 제외하고 뒷숫자 추가하는 하는 방식
배열 전체 순회한번하면 찾을 수 있음

### 계획
counter로 숫자 갯수 검사하고, deque로 앞숫자 제외하고 뒷숫자 추가하는 하는 방식
갯수가 1이상인 숫자가 3개 이상이면 queue에서 pop()
pointer를 오른쪽으로 움직이며 다음 숫자 queue에 append
1이상인 숫자의 갯수를 확인하여 max보다 크면 업데이트
### 코드
```python
import sys
input = sys.stdin.readline
from collections import deque


def solve(N:int, arr:list[int])-> int:
    max_len = 0
    q = deque([])
    cnt = [0] * 10
    def count_type(cnt:list[int]) -> int:
        type_cnt = 0
        for c in cnt:
            if c > 0:
                type_cnt += 1
        return type_cnt
    def count_max_len(cnt:list[int]) -> int:
        len = 0
        for c in cnt:
            len += c
        return len
    for i, num in enumerate(arr):
        q.append(num)
        cnt[num] += 1
        while count_type(cnt) > 2:   
            n = q.popleft()
            cnt[n] -= 1
        max_len = max(max_len, count_max_len(cnt))
    return max_len


if __name__ == "__main__":
    [N] = map(int, input().split())
    arr = list(map(int, input().split()))
    result = solve(N, arr)
    print(result)
```
투포인터 개선
```python
import sys
input = sys.stdin.readline


def solve(N:int, arr:list[int])-> int:
    max_len = 0
    left = 0
    cnt = [0] * 10
    type_cnt = 0
    for right, x in enumerate(arr):
        if cnt[x] == 0:
            type_cnt += 1
        cnt[x] += 1
        while type_cnt > 2:
            y = arr[left]
            cnt[y] -= 1
            if cnt[y] == 0:
                type_cnt -= 1
            left += 1
        max_len = max(max_len, right - left + 1)
    return max_len


if __name__ == "__main__":
    [N] = map(int, input().split())
    arr = list(map(int, input().split()))
    result = solve(N, arr)
    print(result)

```
### 회고
투포인터를 사용하면 더 간단하게 풀 수 있음
	마지막 숫자만 기억하면 되기때문에 포인터로 위치만 기억
	매번 cnt 배열 전체를 돌면서 계산할 필요 없음