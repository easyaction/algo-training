[link](https://www.acmicpc.net/problem/11724)
### 문제 이해
첫번째 줄 정점의 갯수 N / 간선 갯수 M
둘째 줄 M개의 줄에 간선 양 끝점 u v
연결 요소 갯수를 구하라?
연결 요소 갯수? 연결되어있는 묶음의 갯수?
1 -2 -5 3-4-6

### 추상화
그래프 DFS / BFS를 통해 unique 방문 횟수를 구하는 문제
그래프 초기화 후, 방문하지 않은 정점이라면 count를 증가하고 연결된 정점을 DFS/BFS로 방문 처리
	이미 방문한 정점이라면 스킵

### 계획
그래프 초기화
visted를 정점 갯수만큼 초기화
graph 2차원 배열
graph [ u ] 에 v 를 append


bfs 구현
for n in range(node)
	queue에 node 인입
	  queue가 빌때까지
	pop한 노드가 visited면 종료
	아니면
	  count ++
	  q에 graph[ node ] 를 append
  
### 코드
```python
import sys
input = sys.stdin.readline
from collections import deque


def solve(N, M, graph):
    visited = [ False ] * (N+1)
    visited[0] = True # index 0 처리
    cnt = 0
    for n in range(1, N+1):
        if visited[n]:
            continue
        cnt += 1
        q = deque([n])
        while q:
            node = q.popleft()
            if visited[node]:
                continue
            visited[node] = True
            q.extend(graph[node])
    return cnt


if __name__ == "__main__":
    [N, M] = map(int, input().split())
    graph = [[] for _ in range(N+1)] 
    for _ in range(M):
        [u, v] = map(int, input().split())
        graph[u].append(v)
        graph[v].append(u)
    result = solve(N, M, graph)
    print(result)

```
개선
```python
import sys
input = sys.stdin.readline
from collections import deque


def solve(N, M, graph):
    visited = [ False ] * (N+1)
    visited[0] = True # index 0 처리
    cnt = 0
    for n in range(1, N+1):
        if visited[n]:
            continue
        cnt += 1
        visited[n] = True
        q = deque([n])      
        # bfs
        while q:
            node = q.popleft()
            for nxt in graph[node]:
                if not visited[nxt]:
                    visited[nxt] = True
                    q.append(nxt)
    return cnt


if __name__ == "__main__":
    [N, M] = map(int, input().split())
    graph = [[] for _ in range(N+1)] 
    for _ in range(M):
        [u, v] = map(int, input().split())
        graph[u].append(v)
        graph[v].append(u)
    result = solve(N, M, graph)
    print(result)
```
### 회고
양방향 그래프로 초기화해야함
count하는 조건이 뭔지 정확하게 생각하고 접근하는 것도 좋겠다
TC를 직접 고민해볼 필요가 있다.
	testcase.ac 는 틀렸을때에만 사용
중복 enqueue를 제거하자.
	