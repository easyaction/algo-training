[link](https://www.acmicpc.net/problem/2630)
### 문제 이해
한변의 길이 N, 각각의 색상(0/1)이 주어질때
전체 종이가 같은 색상이 아니라면 가로 세로 중간부분 잘라 N/2 x N/2로 자름
이를 똑같은 색상이 될때까지 반복(모두 동일한 색상이거나 1개까지 줄어들때)
최종적으로 잘라진 사각형의 갯수?
N = {2,4,8,16,32,64,128} 중 하나
### 추상화
brute-force로 센다하면, 
128 * 128 대략 10 * 4 정도
재귀적으로 호출하면서 세면 되지않을까
전부 동일하면 해당 색종이의 색상에 해당하는 문자열을 반환
동일하지 않으면 N/2로 나눠 재귀 호출
반환한 문자열 각각의 갯수를 세서 반환
### 계획
def check(list)->string
	리스트의 길이를 기준으로 이중 포룹으로 확인
	첫번째 요소의 색깔을 기준으로, 이후 모두 동일한지 확인
		동일하지 않으면 check를 재귀호출 (네개의 영역으로 나눠 호출)
	동일하면 첫번째 요소 반환
전체를 호출하여 얻은 문자열의 0,1을 세서 반환
### 코드
```python
import sys

input = sys.stdin.readline
from collections import Counter


def solve(array):
    def check_color(list):
        first_element = list[0][0]
        N = len(list)
        for i in range(N):
            for j in range(N):
                if first_element != list[i][j]:
                    return check_color([row[:N // 2] for row in list[:N // 2]]) + check_color([row[:N // 2] for row in list[N//2:]]) + check_color([row[N // 2:] for row in list[:N // 2]]) + check_color([row[N // 2:] for row in list[N // 2:]])
        return first_element
    result = check_color(array)
    cnt = Counter(result)
    return [cnt['0'], cnt['1']]


if __name__ == "__main__":
    [N] = input().split()
    array = []
    for i in range(int(N)):
        array.append(input().split())
    result = solve(array)
    print(result[0])
    print(result[1])

```
### 회고
python에서 sub-matrix 하는 법
```python
sub = [row[col_start:col_end] for row in matrix[row_start:row_end]]	
```
매번 슬라이싱하지말고 인덱스로 접근하는 것이 명확함
counter도 제거해야함
	재귀 호출을 하되, 전역변수를 증가시키는게 낫겠다.