[link](https://www.acmicpc.net/problem/21736)
### 문제 이해
NxM 캠퍼스를 이동하여 만날수 있는 사람의 수 구하기
N <= 600 M <= 600
o는 빈공간, x는 벽, I는 도연이, P는 사람
I 에서부터 주변 탐색해서 P 갯수 찾기
### 추상화
dfs/bfs 탐색 문제
입력을 저장할때 I의 좌표를 찾아서 전달하고, 이를 기준으로 탐색
상하좌우 탐색할때 X가 나오면 종료. P가 나오면 count+
count == 0 -> TT로 출력
### 계획
BFS로 풀기
N,M 받아서 N만큼 반복하면서 입력을 받음
이때 각 입력에서 I를 찾아서 시작 좌표 저장
BFS를 구현하는데, o, p가 나오면 상하좌우 탐색 계속 x는 중단
o, p 방문 후 X로 변경
좌표가 0<=N , M을 만족할때에만 계속 탐색
### 코드
```python
import sys
input = sys.stdin.readline
from collections import deque


def solve(N:int, M:int, x:int, y:int, campus:list[list[str]])-> str:
    cnt = 0
    q = deque([(x,y)])
    # bfs
    while q:
        [x,y] = q.popleft()
        if 0<=x<=N-1 and 0<=y<=M-1:
            val = campus[x][y]
            if val == "X":
                continue
            elif val == "P":
                cnt += 1
            campus[x][y] = "X"
            q.append((x-1, y))
            q.append((x+1, y))
            q.append((x, y-1))
            q.append((x, y+1))
    return "TT" if cnt == 0 else str(cnt)


if __name__ == "__main__":
    [N, M] = map(int, input().split())
    campus = [] 
    x,y = -1, -1
    for i in range(N):
        n = list(input().split()[-1])
        if "I" in n:
            x = i
            y = n.index("I")
        campus.append(n)
    result = solve(N, M, x, y, campus)
    print(result)

```
개선
```python
import sys
input = sys.stdin.readline
from collections import deque


def solve(N:int, M:int, x:int, y:int, campus:list[list[str]])-> str:
    cnt = 0
    campus[x][y] = "X"
    q = deque([(x,y)])
    directions = [(0,1), (1,0), (-1, 0), (0,-1)]
    # bfs
    while q:
        x,y = q.popleft()

        for dx, dy in directions:
            nx = x + dx
            ny = y + dy
            if not (0<=nx<=N-1 and 0<=ny<=M-1):
                continue
            val = campus[nx][ny]
            if val == "X":
                continue
            elif val == "P":
                cnt += 1
            campus[nx][ny] = "X"
            q.append((nx, ny))
    return "TT" if cnt == 0 else str(cnt)


if __name__ == "__main__":
    [N, M] = map(int, input().split())
    campus = [] 
    x,y = -1, -1
    for i in range(N):
        n = list(input().rstrip())
        if "I" in n:
            x = i
            y = n.index("I")
        campus.append(n)
    result = solve(N, M, x, y, campus)
    print(result)

```
### 회고
무조건 큐에 넣어 두고 나서 들어가서 방문처리를 하는데, 이것때문에 불필요한 방문이 많아짐
	해당 값을 보고 필요한 값만 큐에 넣는게 좋다.
	nxt 값을 이용하여 값을 가져와서 q에 넣을지 판단하자.
split()[-1] 보다 rstrip()이 더 적합