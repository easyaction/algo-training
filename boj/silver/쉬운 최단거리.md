[link](https://www.acmicpc.net/problem/14940)
### 문제 이해
모든 지점에서 목표 지점까지의 거리 구하기
목표 지점 - 2
1은 갈수있고 0은 못감
2<= n,m <= 1000 
n x m 
### 추상화
bfs를 이용하여 목표지점으로부터 다른 1로 방문하며 거리를 계산하여 업데이트
### 계획
2차원 배열 초기화
	2가 있는 지점의 좌표를 찾아 별도로 저장(탐색 시작 지점)
		0으로 변환하여 배열에 저장
	0은 갈수 없고, 1은 -1로 변환하여 저장
bfs로 시작지점으로부터 주변을 탐색하며 거리 업데이트
	-1인 경우에만 탐색가능
### 코드
```python
import sys

input = sys.stdin.readline
from collections import deque


def solve(arr: list[list[int]], N, M, sx, sy: int) -> list[list[int]]:
    dirs = [(1, 0), (0, 1), (-1, 0), (0, -1)]
    q = deque([(sx, sy)])
    while q:
        (x, y) = q.popleft()
        for dx, dy in dirs:
            nx = x + dx
            ny = y + dy
            if 0 <= nx < N and 0 <= ny < M and arr[nx][ny] == -1:
                arr[nx][ny] = arr[x][y] + 1
                q.append((nx, ny))
    return arr


if __name__ == "__main__":
    [N, M] = map(int, input().split())
    arr = []
    x, y = -1, -1
    for n in range(N):
        line = []
        for m, num in enumerate(map(int, input().split())):
            if num == 2:
                x = n
                y = m
                line.append(0)
            elif num == 1:
                line.append(-1)
            else:
                line.append(0)
        arr.append(line)
    results = solve(arr, N, M, x, y)
    for r in results:
        print(" ".join(map(str, r)))

```
개선
```python
import sys
from collections import deque

input = sys.stdin.readline

def solve():
    N, M = map(int, input().split())
    
    # 맵 입력 및 초기 설정
    arr = []
    start_node = None
    
    for i in range(N):
        row = list(map(int, input().split()))
        for j in range(M):
            if row[j] == 2:
                start_node = (i, j)
                row[j] = 0  # 시작점 거리는 0
            elif row[j] == 1:
                row[j] = -1 # 방문 전 갈 수 있는 곳은 -1로 초기화
        arr.append(row)

    if not start_node:
        return arr

    # BFS 탐색
    q = deque([start_node])
    dirs = [(1, 0), (-1, 0), (0, 1), (0, -1)]

    while q:
        x, y = q.popleft()
        
        for dx, dy in dirs:
            nx, ny = x + dx, y + dy
            
            # 인덱스 범위 안이고, 아직 방문하지 않은(-1) 갈 수 있는 길이라면
            if 0 <= nx < N and 0 <= ny < M and arr[nx][ny] == -1:
                arr[nx][ny] = arr[x][y] + 1
                q.append((nx, ny))
                
    return arr

if __name__ == "__main__":
    result = solve()
    for row in result:
        print(*row) # 언패킹을 이용한 간결한 출력

```
### 회고
print(* r)을 이용하면 iterable을 언패킹하여 전달
	print()은 인자간에 space 넣어서 출력함