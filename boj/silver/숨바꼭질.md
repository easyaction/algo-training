[link](https://www.acmicpc.net/problem/1697)
### 문제 이해
A의 위치 N, B의 위치 K가 주어질때, 다음 행동 할 수 있음
A 위치 X일때, 
1초 뒤 X+1 / X-1
1초 뒤 2 * X
N에서 K로 이동하는 최단 시간을 구하라
N,  K <= 10 ^ 5
### 추상화
DP ?
위치 X로 이동하는데 필요한 최소 시간을 dp[X]라고 할때, 
dp[X+1]을 아래와 같이 정의해볼 수 있다.
```python
dp[X+1] = min(dp[X], dp[X+2], dp[X//2]) + 1
```
이전의 상태가 다음 상태로 이어져야하는데, 뒷 상태가 앞 상태에 영향을 줄 수 있음. DP가 아님

bfs?로 직접 탐색하면서 업데이트
	시작 X로부터 X+1, X-1, 2X를 q에 넣어가며 step을 증가
	K를 찾으면 종료

### 계획
bfs를 구현
	튜플에 대해 동작하도록 구현한다.
		(값, step)
	visited 배열을 만들어 이미 방문한 값에 대해서는 탐색하지 않도록
	q에서 pop하고, 방문 처리
	step이 10 ^ 5 면 종료
	X == k 면 step을 반환
	X가 N <= X < 2K 일때만 동작
		X+1, X-1, 2X에 대하여 방문하였는지 확인
			방문하지 않았다면 해당 값을 enqueue
최초 (N, 0)를 q에 넣는다

### 코드
```python
import sys
input = sys.stdin.readline
from collections import deque

INF = int(2e5)

def solve(N:int, K:int)-> int:
    visited = [ False for _ in range(INF+1)]
    q = deque([(N, 0)])
    visited[N] = True
    nxt_funcs = [lambda x:x+1, lambda x:x-1, lambda x:2*x]
    while q:
        cur, step = q.popleft()
        if step > INF:
            continue
        if cur == K:
            return step
        for func in nxt_funcs:
            nxt = func(cur)
            if 0 <= nxt < max(2*N, 2*K) and not visited[nxt]:
                visited[nxt] = True
                q.append((nxt, step+1))
    return -1


if __name__ == "__main__":
    N, K = map(int, input().split())
    result = solve(N, K)
    print(result)

```
### 회고
메모리 할당 경계처리 잘못함
