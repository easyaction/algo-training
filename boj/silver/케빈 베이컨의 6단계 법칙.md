[link](https://www.acmicpc.net/problem/1389)
### 문제 이해
사용자와 친구 관계가 주어졌을때, 케빈 베이컨의 수가 가장 작은 사람을 구하라
케빈 베이컨 수 - 특정 사용자와 다른 모든 사용자와의 최소 단계의 합

### 추상화
그래프 최단 경로 구하는 문제.
특정 노드에서 다른 모든 노드로의 최단 경로의 합을 각각 구해서 이의 최소값을 구하기
플로이드 워셜 알고리즘?(다이나믹 프로그래밍)
점화식 설계 - a에서 b로 가는 간선보다 k를 거쳐갔을때 더 짧은 거리가 있다면 그 값으로 업데이트

### 계획
그래프 초기화
	2차원 배열 선언. 모든 경로 inf로 초기화. 자기 자신은 0으로 값 설정
	입력에서의 친구관계에 따라 1로 값 업데이트
		a -> b / b -> a 모두 설정
플로이드 워셜
	중간 노드 k에 대하여(1->n)
		시작 노드 a (1 -> n)
			종료 노드 b ( 1->n)
```
				graph[ a ][ b ] = min(graph[a][b], graph[a][k] + graph[k][b])
```
최소값 찾기
	min_user = 0
	min_val = 0
	for i = 1 -> n
		kevin_num = sum(graph[i])
		if kevin_num < min_val:
			min_val = kevin_num
			min_user = i
### 코드
```python
import sys
input = sys.stdin.readline

INF = int(1e9)

def solve(N:int, graph:list[list[int]])-> int:
    # floyd-warshall alg
    for k in range(1, N+1):
        for a in range(1, N+1):
            for b in range(1, N+1):
                graph[a][b] = min(graph[a][b], graph[a][k] + graph[k][b])
    # find minimum bacon number
    min_user = 0
    min_bn = INF
    for i in range(1,N+1):
        bn = 0
        for j in range(1, N+1):
            bn += graph[i][j]
        if min_bn > bn:
            min_bn = bn
            min_user = i
    return min_user


if __name__ == "__main__":
    N, M = map(int, input().split())
    # init graph
    graph = [[INF for _ in range(N+1)] for _ in range(N+1)]
    for i in range(1, N+1):
        graph[i][i] = 0
    for _ in range(M):
        a, b = map(int, input().split())
        graph[a][b] = 1
        graph[b][a] = 1
    
    result = solve(N, graph)
    print(result)
```
### 회고
플로이드 워셜 몰라서 공부해서 구현함
	DP로 점화식 설계하는게 키
	두 노드의 거리와 다른 노드를 중간에 거쳐서 가는 거리중 최소값을 취하는 방법
pythonic하게 개선하기
```python
	bn = sum(graph[i][1:])
```
bfs로도 풀 수 있다. 다시 풀어보자.
