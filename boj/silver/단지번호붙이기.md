[link](https://www.acmicpc.net/problem/2667)
### 문제 이해
1-집 0-집이 없는곳
집이 붙어있는 단지를 정의하고, 단지 번호 붙이기
대각선으로 연결된건 다른 단지
단지 수 출력하고, 각 단지의 집 수를 오름차순으로 출력
입력 - 지도 크기 N (NxN)
N줄에 N개의 0 혹은 1

### 추상화
dfs/bfs를 이용한 탐색 - bfs로 구현
배열을 순회하되, 1이 나오면 주변을 bfs로 탐방하며 주변 인접 집을 탐색.
단지 배열을 만들어서 새 집을 발견하면 1을 append
	bfs하면서 마지막 요소의 값을 증가(1의 갯수만큼 증가)

### 계획
배열 초기화
	input().rstrip() 이용
결과 배열 선언
이중 포룹으로 2차원 배열 순회하며
	값이 1인경우
		결과 배열에 1을 추가
		상하좌우에 대하여 bfs하며 탐색할때마다 결과 배열의 마지막 값을 +1
			다음 좌표가 0 <= x, y < N 일때 && 해당 값이 1일때만 탐색
결과 배열 길이 출력
오름차순으로 정렬하여 출력
### 코드
```python
import sys

input = sys.stdin.readline
from collections import deque


def solve(arr: list[list[int]], N: int) -> list[int]:
    results = []
    for i in range(N):
        for j in range(N):
            if arr[i][j] != 1:
                continue
            arr[i][j] = 0
            results.append(1)
            q = deque([(i, j)])
            dirs = [(1, 0), (0, 1), (-1, 0), (0, -1)]
            while q:
                x, y = q.popleft()
                for dx, dy in dirs:
                    nxt_x, nxt_y = x + dx, y + dy
                    if 0 <= nxt_x < N and 0 <= nxt_y < N and arr[nxt_x][nxt_y] == 1:
                        arr[nxt_x][nxt_y] = 0
                        results[-1] += 1
                        q.append((nxt_x, nxt_y))
    return sorted(results)


if __name__ == "__main__":
    [N] = map(int, input().split())
    arr = []
    for _ in range(N):
        arr.append(list(map(int, input().rstrip())))
    results = solve(arr, N)
    print(len(results))
    for n in results:
        print(n)

```
개선
```python
import sys

input = sys.stdin.readline
from collections import deque


def solve(arr: list[list[int]], N: int) -> list[int]:
    results = []
    dirs = [(1, 0), (0, 1), (-1, 0), (0, -1)]
    for i in range(N):
        for j in range(N):
            if arr[i][j] != 1:
                continue
            arr[i][j] = 0
            cnt = 1
            q = deque([(i, j)])
            while q:
                x, y = q.popleft()
                for dx, dy in dirs:
                    nxt_x, nxt_y = x + dx, y + dy
                    if 0 <= nxt_x < N and 0 <= nxt_y < N and arr[nxt_x][nxt_y] == 1:
                        arr[nxt_x][nxt_y] = 0
                        cnt += 1
                        q.append((nxt_x, nxt_y))
            results.append(cnt)
    return sorted(results)


if __name__ == "__main__":
    [N] = map(int, input().split())
    arr = []
    for _ in range(N):
        arr.append(list(map(int, input().rstrip())))
    results = solve(arr, N)
    print(len(results))
    for n in results:
        print(n)

```
### 회고
결과 배열에 주택 수를 매번 넣지말고, 지역 변수 만들고 다 센 뒤에 한번만 넣어도 됨
방향 배열을 상수로 선언