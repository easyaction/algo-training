link : https://www.acmicpc.net/problem/2606
문제 이해
1번 컴퓨터와 연결된 컴퓨터의 수를 출력
입력
첫번째 줄(N) : 컴퓨터의 총 수 N <= 100
두번째 줄(M) : 연결 쌍 수
이후 M개의 연결 쌍 출력

재정의와 추상화
컴퓨터 : 노드 
연결 : 엣지
그래프 완전 탐색?
1번 노드와 연결된 노드 수를 세면 됨

계획
그래프 완전 탐색 기억안나지만 일단 해보자.

입력에 대하여 그래프 자료구조 구성
완성된 그래프를 탐색
너비 우선 탐색이 더 간단하니 이걸 먼저하고, 나중에 깊이 우선 탐색을 해보자.
그래프 구성 방법
인접 행렬로 해도 되겠다. 최대 백개면 100x100이면 그다지 크지 않음
장단점에 대해서 다시 정리할 필요 있음
인접 리스트로 처리하는 것이 좋다. 행렬은 순회하는 것이 힘들다.

코드
```
package main

import (
	"bufio"
	"fmt"
	"os"
)

var reader *bufio.Reader = bufio.NewReader(os.Stdin)
var writer *bufio.Writer = bufio.NewWriter(os.Stdout)

type Queue struct {
	list []int
}

func NewQueue() *Queue {
	var list []int
	return &Queue{list:list}
}

func (q *Queue) Enqueue(n int) {
	q.list = append(q.list, n)
}

func (q *Queue) Dequeue() int {
	if len(q.list) == 0 {
		return -1
	}
	n := q.list[0]
	q.list = q.list[1:]
	return n
}

func (q *Queue) Len() int {
	return len(q.list)
}

func main() {
	defer writer.Flush()
	var nodes int
	fmt.Fscan(reader, &nodes)
	var edges int
	fmt.Fscan(reader, &edges)
	// make a graph with edges
	graph := make(map[int]map[int]bool)
	for i := range nodes {
		graph[i+1] = make(map[int]bool)
	}
	for _ = range edges {
		var i,j int
		fmt.Fscan(reader, &i, &j)
		graph[i][j] = true
	    graph[j][i] = true 
	}

	// search
	visited := make(map[int]bool, nodes)
	q := NewQueue()
	q.Enqueue(1)
	
	for q.Len() > 0 {
		n := q.Dequeue()
		visited[n] = true
		// bfs
		if _, ok := graph[n]; ok {
			for k := range graph[n] {
				if _, ok := visited[k]; !ok {
					q.Enqueue(k)
				}
			}
		}
	}
	// without node 1
	fmt.Fprintln(writer, len(visited)-1)
}
```

회고
~~그래프 초기화시 양방향 모두를 인접 리스트에 넣어줬는데, 그럴 필요 없었다. ~~
	단방향으로만 하는것이 효율적이다.
	인접 행렬도 동일. 윗 삼각형 영역만 탐색하면 됨
	오히려 양방향 그래프라 둘다 넣어줘야 정상적으로 동작한다.
		양방향을 처리하지 않으면 1이 자식노드가 되어버리면 제대로 동작하지 않음
	반례
	in
	```
	7
	6
	2 1
	2 3
	5 1
	5 2
	5 6
	4 7
	```
	out 0 ans 4
dfs로 했다면?
	