[link](https://www.acmicpc.net/problem/18870)
### 문제 이해
수직선 좌표 Xi
좌표 압축?
	Xi' = Xi > Xj를 만족하는 Xj의 갯수
좌표 갯수 N <= 10 ^ 6
### 추상화
중복 없는 정렬 한 뒤 몇번째 원소인지 구하는 문제

### 계획
list를 unique list로 만들기 (set -> list)
정렬(O(nlogn))
dict 변환 (O(n))
list원소에 대하여 dict 조회 하여 index 계산
### 코드
```python
import sys

input = sys.stdin.readline


def solve(array: list[int]):
    unique_arr = list(set(array))
    unique_arr.sort()
    idx_dict = {n: idx for idx, n in enumerate(unique_arr)}
    print(" ".join([str(idx_dict.get(num)) for num in array]))


if __name__ == "__main__":
    [N] = map(int, input().split())
    array = list(map(int, input().split()))
    solve(array)
```
개선
```python
import sys

input = sys.stdin.readline


def solve(array: list[int]):
    uniq = sorted(set(array))
    comp = {v: i for i, v in enumerate(uniq)}
    print(" ".join(str(comp[x]) for x in array))


if __name__ == "__main__":
    [N] = map(int, input().split())
    array = list(map(int, input().split()))
    solve(array)

```
### 회고
결과 join에 전달할때 list comprehension보다 map이 더 빠르다?
	제네레이터를 전달해서(중괄호 제외) 하는 방법도 있다
		memory를 절약할 수 있으나, 속도는 더 느리다고 함
			lazy evaluation 하기때문에 메모리를 절약
	제미나이 답변
		속도 : map >= list comprehension >> generator
		메모리 : generator >> map = list comprehension
	라고 하는데, 실제로는 셋다 또이또이
		가독성 측면에서 generator 전달로 작업
index가 존재하는 것이 확정이므로 get() 쓸 필요 없다