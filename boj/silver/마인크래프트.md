[link](https://www.acmicpc.net/problem/18111)
### 문제 이해
집을 짓기위해 평탄화 작업
세로 n, 가로 m을 고르면 맨 위쪽을 (0,0)로 놓고 집터 내의 땅을 평탄화
두가지 작업 가능
i,j 맨 위의 블록을 제거하여 인벤토리에 넣기 - 2초
인벤토리에서 블록 하나 꺼내서 i,j의 가장 위에있는 블록 위에 놓기 - 1초
최소 시간과 그 경우의 땅의 높이
시작할때 인벤토리에 B개의 블록이 들어있음
땅의 높이는 256 블록 초과 불가능 / 음수가 될수 없음

입력
N, M, B
땅의 높이 NxB
### 추상화
브루트포스..?
파는데 2초가 소요되므로, 이를 최소화 하는것이 좋음
NxB 중 가장 갯수가 많은 높이 순으로 선택 이를 만드는데 소요되는 시간 계산
만들기 가능한지 확인
갯수 많은 높이가 여러개라면, 가장 높은 값부터 검증

### 계획
1차원 배열에 NxM 높이를 저장
높이 중 max value부터 감소하며 검증
	검증 방법
		갯수가 가장 많은 숫자와의 차이를 전부 계산 이게 0 이상이면 가능
		양수인 부분은 곱하기 2하고 음수인 부분은 1 하여 count를 계산
		시간이 지금보다 짧거나, max count 보다 크면 업데이트

### 코드
기존(pypy에서만 통과)
```python
import sys

input = sys.stdin.readline


def solve(B: int, array: list[int]) -> tuple[int, int]:
    start = max(array)
    end = min(array)
    min_seconds = int(1e9)
    max_height = start
    for target in range(start, end - 1, -1):
        seconds = 0
        lower = 0
        higher = 0
        for h in array:
            diff = h - target
            if diff < 0:
                lower += diff
            else:
                higher += diff
        if B + lower + higher < 0:
            continue
        else:
            seconds = abs(lower) + 2 * higher
        if seconds <= min_seconds:
            if not seconds == min_seconds:
                max_height = target
            min_seconds = seconds
    return (min_seconds, max_height)


if __name__ == "__main__":
    [N, M, B] = map(int, input().split())
    array = []
    for _ in range(N):
        m = map(int, input().split())
        array.extend(m)
    [seconds, height] = solve(B, array)
    print(seconds, height)
```
개선
```python
import sys

input = sys.stdin.readline
from collections import Counter


def solve(B: int, array: list[int]) -> tuple[int, int]:
    min_seconds = int(1e9)
    max_height = 0
    cnt = Counter(array)
    for target in range(min(array), max(array) + 1):
        lower = 0
        higher = 0
        for h, count in cnt.items():
            if h < target:
                lower += (target - h) * count
            else:
                higher += (h - target) * count
        if B - lower + higher < 0:
            continue
        else:
            seconds = lower + 2 * higher
            if seconds <= min_seconds:
                min_seconds = seconds
                max_height = target
    return (min_seconds, max_height)


if __name__ == "__main__":
    [N, M, B] = map(int, input().split())
    array = []
    for _ in range(N):
        m = map(int, input().split())
        array.extend(m)
    [seconds, height] = solve(B, array)
    print(seconds, height)
```
### 회고
counter를 사용하여 배열 접근 횟수를 줄일 수 있음
	array가 NxM이기 때문에 256 x 250,000 이라 timeout 남
	미리 계산해둔 상태에서 존재하는 높이와 갯수로 계산하면 빠르게 계산 가능
높은 높이부터 아래로 찾았는데, 그냥 순서대로 찾는게 더 직관적이겠다.
	어차피 브루트포스라면, 아래에서 위로 가는게 더 직관적
처음 접근을 브루트포스로 할 생각을 잘 못했다.
	방법 안떠올라서 그냥 브루트포스로 했는데, 먼저 브루트 포스로 풀어볼 생각부터 항상 하자.