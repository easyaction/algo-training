[link](https://www.acmicpc.net/problem/1012)
### 문제 이해
2차원 배열(1 - 배추, 0 - 땅) 주어질때, 인접한 배추를 한 묶음으로 볼때 총 몇 묶음인지 확인
TC 갯수 - T, MxN 배열. 배추 위치 갯수 k, 배추 좌표 (x,y)
### 추상화
dfs/bfs로 인접한 1을 방문하는 문제
특정 노드를 방문하고 나서 상하좌우를 방문하면서 1->0으로 변경
한번 방문하면 count 증가
### 계획
반복문을 돌면서 1인 경우 count++ 하면서 주변 노드 방문처리
방문처리? 해당 노드 1->0으로 변경
우선 dfs부터 구현
	m x n 배열과 x,y 좌표를 입력으로 받아서
	 0 <= x, y <= m,n
		해당 x,y를 0으로 변경
		(x-1, y), (x+1,y), (x,y-1), (x,y+1) 호출

### 코드
```python
import sys
sys.setrecursionlimit(100000)

def solve(array) -> int:
  def dfs(array, x, y):
    if 0 <= x < len(array) and 0 <= y < len(array[0]) and array[x][y] == 1:
      array[x][y] = 0
      dfs(array, x-1, y)
      dfs(array, x+1, y)
      dfs(array, x, y-1)
      dfs(array, x, y+1)
  count = 0
  for x in range(len(array)):
    for y in range(len(array[x])):
      if array[x][y] == 1:
        count += 1
        dfs(array, x, y)
  return count


if __name__ == '__main__':
  [T] = input().strip().split()
  for _ in range(int(T)):
    [M, N, K] = input().strip().split()
    mn = [[0 for _ in range(int(N))] for _ in range(int(M))]
    for _ in range(int(K)):
      [X,Y] =input().strip().split()
      mn[int(X)][int(Y)] = 1
    print(solve(mn))
```
### 회고
dfs로 우선 간단하게 풀었고, bfs로 