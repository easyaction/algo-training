https://www.acmicpc.net/problem/17626
#### 문제 이해
어떤 자연수는 4개 이해 제곱수의 합으로 표현 가능하다
이때 필요한 숫자의 최소 갯수 구하기
1, 4, 9, 16(4 * 4), ... , 50176(224 * 224)
1<=n<=5 * 10^4
#### 문제 추상화
주어진 숫자에서 가장 가까운 제곱수를 빼주면서 0이 될때까지 하면 되지 않을까
예를 들면
30 -> 30 - 25 -4 - 1 = 3
이를 위해 숫자별로 가장 가까운 제곱수를 구해둬야함
-> 잘못된 가정

내가 가정하지말고, 브루트포스 구현해보면?
숫자 네개를 골라 해당 값을 만족하는 것을 찾는다. - O(N^4)...
왼쪽 두개 고르고, l r 투포인터로 나머지 두개를 고르면 - O(N^3)
중복되는 상태가 있을까?

어차피 4개 안에서 결정된다는 것을 아니까, 제곱수를 빼가면서 depth가 4이상이 되면 종료해도 되겠다.

그냥 브루트 포스로 한개인 경우, 2개인 경우, 3개인 경우, 아니면 4개 이런식으로 구할 수도 있다.
#### 계획
5만개 전부 선언하지 말고, 이진 탐색으로 빠르게 값을 찾자. 
logN이어도 최대 4회 방문하기때문에 O(N) 보다 낫다.
하지만 최소 횟수가 아님.

### 코드
DP
```python
INF = 10**9

def solve(n:int) -> int:
  dp = [INF] * 50001 # 1 <= n <= 50000, 0은 미사용
  dp[0] = 0
  # 제곱 수 초기화
  squares = []
  i = 1
  while i*i <= n:
    squares.append(i*i)
    dp[i*i] = 1
    i += 1
  for x in range(1, n+1):
    for s in squares:
      if x < s:
        break
      dp[x] = min(dp[x], dp[x-s] + 1)
  return dp[n]


if __name__ == '__main__':
  [n] = input().strip().split()
  print(solve(int(n)))
```

### 회고
DP의 상태 정의가 여전히 어렵다.
처음에 생각했었던 BF로 쭉 한번 작성해볼걸 싶기도.
BFS로도 구현 해보자.